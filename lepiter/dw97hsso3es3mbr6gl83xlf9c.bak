{
	"__schema" : "4.1",
	"__type" : "page",
	"children" : {
		"__type" : "snippets",
		"items" : [
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2023-03-02T09:19:17.185901+01:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2023-03-02T09:20:10.784891+01:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "ruHGOEiyDQCH0EGSBFhPBg=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "I started working with SmaCC, but then switched to PP to see if it would make the job of writing a YAML parser easier."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2023-03-02T09:20:11.09882+01:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2023-03-02T09:20:57.122496+01:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "TIP9O0iyDQCKNqkcBFhPBg=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "On the plus side, PP parsers are compositional, so it's easier to prototype and test fragments. On the negative side, PP is scannerless, so we cannot easily simulate INDENT and DEDENT tokens."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2023-03-02T09:20:58.596767+01:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2023-03-02T09:22:26.07369+01:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "ZD/SPkiyDQCOAFopBFhPBg=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "Currently I'm experimenting with a two-phase approach: first process all indentation, and generate fake INDENT and DEDENT “tokens” represented as text. Then a second phase ignores actual indentation and just looks for these tokens to recognize structure. In that way all indentation context can b"
			}
		]
	},
	"createEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"createTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2023-02-01T10:16:08.706869+01:00"
		}
	},
	"editEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"editTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2023-02-01T10:16:08.706869+01:00"
		}
	},
	"pageType" : {
		"__type" : "namedPage",
		"title" : "PetitParser experiments"
	},
	"uid" : {
		"__type" : "uuid",
		"uuid" : "80adb8a2-01b0-0d00-ac1a-d1240354b8ea"
	}
}